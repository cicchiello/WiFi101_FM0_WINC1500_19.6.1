package com.jfcenterprises.wifi101;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;
import java.io.PrintStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.cert.X509Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.CertificateException;
import java.security.interfaces.RSAPublicKey;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.TimeZone;

import javax.xml.bind.DatatypeConverter;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1InputStream;
import org.bouncycastle.asn1.ASN1OutputStream;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.DERPrintableString;
import org.bouncycastle.asn1.DERUTF8String;
import org.bouncycastle.asn1.DLSequence;
import org.bouncycastle.asn1.DLSet;
import org.bouncycastle.asn1.x509.Time;

public class GenWINC1500CertCPP {

    private static String ThisClassName = "com.jfcenterprises.wifi101.GenWINC1500CertCPP";
    
    byte v1Data[];
    String subject;
    String hash;
    
    public GenWINC1500CertCPP(X509Certificate x509, String certname, PrintStream hps, PrintStream cppps)
	    throws Exception, NoSuchAlgorithmException, IOException {

	hps.println("/* Generated Header File for "+certname+" for WINC1500 flash upload of x509 certificate */");
	hps.println("#ifndef _INCLUDED_"+certname+"_CERTIFICATE_H");
	hps.println("#define _INCLUDED_"+certname+"_CERTIFICATE_H");
	hps.println("");
	hps.println("typedef struct strCertificate Certificate;");
	hps.println("");
	hps.println("const Certificate *"+certname+"_getCertificate();");
	hps.println("");
	hps.println("#endif");
	hps.println("");
	hps.println("/* Generated header File done */");

	
	cppps.println("/* Generated cpp File for "+certname+" for WINC1500 flash upload of x509 certificate */");
	cppps.println("/* Generated by: "+ThisClassName+" */");
	cppps.println("#include \""+headerFilename(certname)+"\"");
	cppps.println("");
	cppps.println("#include \"utility/certificate.h\"");
	cppps.println("");
	cppps.println("");

	/*
	    Produce the NotBefore and NotAfter timestamps.  The content will match what you 
            see by doing this: 
	        > openssl x509 -in NMA_Root.cer -inform der -text -noout
		    Look for this section:
		       Validity
		          Not Before: May 30 10:48:38 2000 GMT
			  Not After : May 30 10:48:38 2020 GMT
	 */
	{
	    TimeZone timeZone = TimeZone.getTimeZone("UTC");
	    Calendar cal = Calendar.getInstance(timeZone);
	    cal.setTime(x509.getNotBefore());
	    
	    int year = cal.get(Calendar.YEAR);
	    int month = cal.get(Calendar.MONTH) + 1;
	    int day = cal.get(Calendar.DAY_OF_MONTH);
	    int hour = cal.get(Calendar.HOUR_OF_DAY);
	    int minutes = cal.get(Calendar.MINUTE);
	    int seconds = cal.get(Calendar.SECOND);
	    cppps.println("static tstrSystemTime validFrom = {"+year+", "+month+", "+day+", "+hour+", "+minutes+", "+seconds+"};");
	}
	
	{
	    TimeZone timeZone = TimeZone.getTimeZone("UTC");
	    Calendar cal = Calendar.getInstance(timeZone);
	    cal.setTime(x509.getNotAfter());
	    
	    int year = cal.get(Calendar.YEAR);
	    int month = cal.get(Calendar.MONTH) + 1;
	    int day = cal.get(Calendar.DAY_OF_MONTH);
	    int hour = cal.get(Calendar.HOUR_OF_DAY);
	    int minutes = cal.get(Calendar.MINUTE);
	    int seconds = cal.get(Calendar.SECOND);
	    cppps.println("static tstrSystemTime validUntil = {"+year+", "+month+", "+day+", "+hour+", "+minutes+", "+seconds+"};");
	}
	
	cppps.println("");
	
	/*
	    Produce the piece that the Atmel docs refer to as the name hash.

            From earlier dumps, it looks like this (always 20 byte length):
	       dumpRootCertV1: Name Hash:
	       00000000: 42ca cf1c 2884 dafb c77e ac5d 0975 3d63
	       00000010: 1efa ad7d
	*/
	cppps.println("#define NAME_HASH_LEN 20");
	cppps.println("static uint8 nameHash[NAME_HASH_LEN] = {");

	byte[] name1hash = getSubjectValueHash(x509);
	for (int i = 0; i < 20; i++) {
	    cppps.print((i % 8) == 0 ? "    " : ", ");
	    cppps.print(String.format("0x%02x", name1hash[i]));
	    if ((i % 8) == 7) cppps.println(",");
	}
	cppps.println("");
	cppps.println("};");
	cppps.println("");
	cppps.println("");
	

	String algo = x509.getPublicKey().getAlgorithm();
	if (!algo.equals("RSA") || !(x509.getPublicKey() instanceof RSAPublicKey))
	    throw new Exception("SSL Certificate must have an RSA Public Key");
	RSAPublicKey publicKey = (RSAPublicKey) x509.getPublicKey();
	
	byte[] publicExponent = publicKey.getPublicExponent().toByteArray();
//	byte[] publicExponentLen = shortToBytes(publicExponent.length);

	/* 
	   Produce the exponent encoding 
	*/
	cppps.println("#define EXPONENT_LEN "+publicExponent.length);
	cppps.print("static uint8 exponentBuf[EXPONENT_LEN] = {");
	for (int i = 0; i < publicExponent.length; i++) {
	    cppps.print((i % 8) == 0 ? "" : ", ");
	    cppps.print(String.format("0x%02x", publicExponent[i]));
	    if ((i % 8) == 7) cppps.println(",");
	}
	cppps.println("};");


	/* 
	   Produce the modulus encoding.  It should be the same content as that produced
	   by: 
	     > openssl x509 -in NMA_Root.cer -inform der -text -noout
	     Look for this section:
   	        Public Key Algorithm: rsaEncryption
		Public-Key: (2048 bit)
		Modulus:
		   00:b7:f7:1a:33:e6:f2:00:04:2d:39:e0:4e:5b:ed:
		   1f:bc:6c:0f:cd:b5:fa:23:b6:ce:de:9b:11:33:97:
		   a4:29:4c:7d:93:9f:bd:4a:bc:93:ed:03:1a:e3:8f:
                      ...
		   42:6f:15:b2:b8:7b:fb:ef:e9:5d:53:d5:34:5a:27
		   
	     IMPORTANT -- if present, omit the leading 00 reported by openssl (It should 
	     be omitted for the encoding here.  The leading 00 is added by openssl to 
	     ensure that the resulting byte stream represents a positive number -- i.e. 
	     the leading sign bit must be 0).  The extra byte has been confirmed as 
	     spurious for my purposes here, by checking on the contents on the WINC1500 
	     using DumpWINC1500Certs for other certificates compared to the openssl report.
	*/
	byte[] publicModulus = publicKey.getModulus().toByteArray();
	if (((publicModulus.length == 257) || (publicModulus.length == 513) || (publicModulus.length == 1025))
	    || (publicModulus[0] == 0)) {
	    publicModulus = Arrays.copyOfRange(publicModulus, 1, publicModulus.length);
	}
	
	cppps.println("#define MODULUS_LEN "+publicModulus.length);
	cppps.println("static uint8 pubkey[MODULUS_LEN] = {");
	for (int i = 0; i < publicModulus.length; i++) {
	    cppps.print((i % 8) == 0 ? "    " : ", ");
	    cppps.print(String.format("0x%02x", publicModulus[i]));
	    if (((i % 8) == 7) && ((i+1) < publicModulus.length)) cppps.println(",");
	}
	cppps.println("\n};");

	cppps.println("");
	cppps.println("");

	/* 
	   Now, implement the main function that pulls everything together!
	 */
        cppps.println("const Certificate *"+certname+"_getCertificate()");
        cppps.println("{");
        cppps.println("  static Certificate certificate;");
        cppps.println("  static int initialized = 0;");
        cppps.println("  ");
        cppps.println("  if (!initialized) {");
        cppps.println("    /* Load Certificate details into the struct */");
        cppps.println("    m2m_memcpy(certificate.nameHash, nameHash, CRYPTO_SHA1_DIGEST_SIZE);");
        cppps.println("    certificate.validFrom = validFrom;");
        cppps.println("    certificate.validUntil = validUntil;");
        cppps.println("    certificate.pubKeyType = X509_CERT_PUBKEY_RSA;");
        cppps.println("    certificate.pubkey.u16NSize = MODULUS_LEN;");
        cppps.println("    certificate.pubkey.u16ESize = EXPONENT_LEN;");
        cppps.println("    certificate.pubkey.pu8N = pubkey;");
        cppps.println("    certificate.pubkey.pu8E = exponentBuf;");
        cppps.println("");
        cppps.println("    initialized = 1;");
        cppps.println("  }");
        cppps.println("");
        cppps.println("  return &certificate;");
        cppps.println("}");
	
	cppps.println("");
	cppps.println("/* Generated cpp File done */");
    }
    
    @Override
    public String toString() {
	return "(" + hash + ")";
    }
    
    private static byte[] shortToBytes(int x) {
	// little endian
	byte ret[] = new byte[2];
	ret[0] = (byte) x;
	ret[1] = (byte) (x >> 8);
	return ret;
    }
    
    private static byte[] encodeTimestampV1(Date timestamp) throws IOException {
	ByteArrayOutputStream encoded = new ByteArrayOutputStream();
	
	TimeZone timeZone = TimeZone.getTimeZone("UTC");
	Calendar cal = Calendar.getInstance(timeZone);
	cal.setTime(timestamp);
	
	int year = cal.get(Calendar.YEAR);
	int month = cal.get(Calendar.MONTH) + 1;
	int day = cal.get(Calendar.DAY_OF_MONTH);
	int hour = cal.get(Calendar.HOUR_OF_DAY);
	int minutes = cal.get(Calendar.MINUTE);
	int seconds = cal.get(Calendar.SECOND);
	
	encoded.write((byte)(year & 0xff));
	encoded.write((byte)((year >> 8) & 0xff));
	encoded.write((byte)(month));
	encoded.write((byte)(day));
	encoded.write((byte)(hour));
	encoded.write((byte)(minutes));
	encoded.write((byte)(seconds));
	encoded.write((byte)(0xcc));
	
	return encoded.toByteArray();
    }
    
    private static byte[] getSubjectValueHash(X509Certificate x509) throws NoSuchAlgorithmException, IOException {
	MessageDigest sha1 = MessageDigest.getInstance("SHA-1");
	ASN1InputStream ais = new ASN1InputStream(x509.getSubjectX500Principal().getEncoded());
	while (ais.available() > 0) {
	    ASN1Primitive obj = ais.readObject();
	    sha1.update(extractPrintableString(obj));
	}
	ais.close();
	return sha1.digest();
    }
    
    private static byte[] extractPrintableString(ASN1Encodable obj) throws IOException {
	if (obj instanceof DERPrintableString) {
	    DERPrintableString s = (DERPrintableString) obj;
	    return s.getString().getBytes();
	} else if (obj instanceof DERUTF8String) {
	    DERUTF8String s = (DERUTF8String) obj;
	    return s.getString().getBytes();
	}
	
	ByteArrayOutputStream res = new ByteArrayOutputStream();
	if (obj instanceof DLSequence) {
	    DLSequence s = (DLSequence) obj;
	    for (int i = 0; i < s.size(); i++) {
		res.write(extractPrintableString(s.getObjectAt(i)));
	    }
	}
	if (obj instanceof DLSet) {
	    DLSet s = (DLSet) obj;
	    for (int i = 0; i < s.size(); i++) {
		res.write(extractPrintableString(s.getObjectAt(i)));
	    }
	}
	return res.toByteArray();
    }
    
    public byte[] getEncodedV1() {
	return v1Data.clone();
    }

    private static X509Certificate loadCertificate(CertificateFactory cf, File f) throws CertificateException, IOException {
	FileInputStream in = new FileInputStream(f);
	try {
	    X509Certificate c=(X509Certificate)cf.generateCertificate(in);
	    c.checkValidity();
	    return c;
	}
	finally {
	    in.close();
	}
    }

    public static String headerFilename(String certname)
    {
	String hfilename = certname+"_winc1500cert.h";
	return hfilename;
    }
    
    public static void usage(String [] args)
    {
	System.out.println("Usage: java -classpath <path to bcprov-jdk15-on-160.jar>:. "+ThisClassName+" [args]");
	System.out.println("where args can be: -c <file> {-odir <dir>}");
	System.out.println("      -help        just prints this message");
	System.out.println("      -c <file>    uses the given file as the DER-encoded certificate to process");
	System.out.println("                   (The basename of the file will be used as the <certname>)");
	System.out.println("      -odir <dir>  directory to put <certname>.{cpp|h} ");
	System.out.println("                   (Defaults to printing to stdout)");
	System.out.println("");
	System.out.println("Note: omitting args entirely just prints this message");
    }
    
    public static void main(String[] args) throws Exception
    {
	if (args.length == 0) {
	    usage(args);
	    return;
	}
	
	String certfile = "";
	String outdir = "-";
	for (int i = 0; i < args.length; i++) {
	    if (args[i].equals("-c") && (i+1 < args.length)) {
		certfile = args[i+1];
		i++;
	    } else if (args[i].equals("-odir") && (i+1 < args.length)) {
		outdir = args[i+1];
		i++;
	    } else {
		System.out.println("ERROR: Unrecognized arg: "+args[i]);
		System.out.println("");
		usage(args);
		return;
	    }
	}
	System.out.println("Using "+certfile+" as DER-encoded certificate file");
	File f = new File(certfile);
	if (!f.exists() || f.isDirectory()) {
	    System.out.println("ERROR: "+certfile+" does not exist or is not a file");
	    System.out.println("");
	    usage(args);
	    return;
	}

	String[] fullPathTokens = certfile.split(".+?/(?=[^/]+$)");
	String[] tokens = fullPathTokens[1].split("\\.(?=[^\\.]+$)");
	String certname = tokens[0];
	String hfilename = headerFilename(certname);
	String cppfilename = certname+"_winc1500cert.cpp";
	PrintStream hps = System.out;
	PrintStream cppps = System.out;
	if (outdir.equals("-")) {
	    System.out.println("Printing generated files to stdout");
	    hfilename = cppfilename = "-";
	} else {
	    if (outdir.substring(outdir.length()-1).equals("/") || outdir.substring(outdir.length()-1).equals("\\"))
		outdir = outdir.substring(0,outdir.length()-1);
	    System.out.println("");
	    System.out.println("Generating files "+outdir+"/"+hfilename+" and "+outdir+"/"+cppfilename);
	    
	    hps = new PrintStream(new File(outdir+"/"+hfilename));
	    cppps = new PrintStream(new File(outdir+"/"+cppfilename));
	}
	
	CertificateFactory cf = CertificateFactory.getInstance("X509");
	X509Certificate cert = loadCertificate(cf, f);

	GenWINC1500CertCPP gen = new GenWINC1500CertCPP(cert, certname, hps, cppps);
	
	System.out.println("");
	System.out.println("");
	System.out.println("Done file generation");
	System.out.println("");
	System.out.println("Now, move:");
	System.out.println("  "+outdir+"/"+hfilename);
	System.out.println("  "+outdir+"/"+cppfilename);
	System.out.println("");
	System.out.println("to your .../sketches/WiFi101/src/utilities/certs folder, then ");
	System.out.println("place the following statement in your UploadRootCerts sketch: ");
	System.out.println("");
	System.out.println("#include \"utility/certs/"+hfilename+"\"");
	System.out.println("");
	System.out.println("Finally, rebuild/upload/run the UploadRootCerts sketch!");
    }
}
